# 1. 객체의 생성
## 1. 객체의 생성
1) 객체 리터럴로 생성하는 방법
    - 객체 리터럴 방식으로 생성된 객체는 결국 빌트인 함수인 Object 생성자 함수로 객체를 생성하는 것을 단순화시킨 축약 표현
    - 자바스크립트 엔진이 내부적으로 해석해 생성하는 것이다.
2) 생성자로 생성하는 방법
    - 여러 개의 객체를 생성할 때 사용
3) Object.create로 생성하는 방법

## 2. 프로토타입
- 함수 객체는 기본적으로 prototype 프로퍼티를 갖고 있다.
- 기본적으로 빈 객체
- 프로토타입 객체의 프로퍼티는 읽기만 가능


# 2. 프로토타입 상속
## 1. 프로토타입 체인
### 내부 프로퍼티`[[Prototype]]`
- 모든 객체는 내부 프로퍼티를 가짐
> 함수 객체의 prototype 프로퍼티와 다른 객체
- ES5 까지는 내부 프로퍼티를 읽거나 쓸 수 없었지만 ES6 `__proto__` 프로퍼티에 값이 저장됨

### 프로토타입 체인
- 객체의 `__proto__` 프로퍼티는 그 객체에게 상속을 해 준 부모 객체를 가리킴
> 객체의 연결 고리 : 프로토타입 체인
- 객체의 `__proto__` 프로퍼티가 가리키는 객체가 상속을 해 준 객체, 이 객체를 그 객체의 프로토타입이라고 한다.
- 객체는 자신이 가지고 있지 않은 특성(프로퍼티와 메서드)을 프로토타입 객체에 위임한다고 할 수 있다.
> 자바스크립트는 프로토타입 체인을 사용하여 객체의 프로퍼티를 다른 객체로 전파시킬 수 있다. 이를 프로토타입 상속이라 한다.

### 프로토타입 가져오기
- 객체의 프로토타입은 Object.getPrototypeOf 메서드로 가져올 수 있다. : ES5 이후
- Object.setPropertyOf 메서드로 객체의 프로토 타입 설정 가능 : ES6 이후

## 2. new 연산자의 역할
- 인스턴스의 프로토타입 체인이 정의되며, 생성자로 생성한 모든 인스턴스가 생성자의 프로토타입 객체의 프로퍼티를 사용할 수 있게 된다.
- 생성자를 new 연산자로 호출하면 객체의 생성, 프로토타입의 설정, 객체의 초기화를 수행

## 3. 프로토타입 객체의 프로퍼티
- 함수를 정의하면 기본적으로 prototype 프로퍼티를 가짐
- 이 prototype 프로퍼티 객체는 프로토타입 객체를 가리키고
- 이 프로토타입 객체는 constructor 프로퍼티와 내부 프로퍼티를 갖는다.

### constructor 프로퍼티
- 함수 객체의 참조를 값으로 가짐.
- 생성자와 생성자의 프로토타입 객체는 서로를 참조
    > F >> F.prototype <br>
    > F.prototype >> F.constructor
- 생성자로 생성한 인스턴스의 경우    
    ```
    obj = new F();

    1. obj는 F.__proto__ 를 가리킴
    2. 생성자로 생성한 인스턴스는 생성될 때의 프로토타입 객체의 참조만 가지고 있다.
    3. 생성자와 직접적인 연결 고리가 없음
    ```
- 인스턴스가 어떤 생성자로 생성된 것인지 알아내는 방법 : constructor 프로퍼티 값 확인

### 내부 프로퍼티 `[[Prototype]]`
- 프로토타입 객체의 프로토타입은 Object.prototype
- 생성자로 생성한 인스턴스는 Object.prototype 사용 가능

### 프로토타입 객체의 교체 및 constructor 프로퍼티
- 새로운 객체를 prototype 프로퍼티 값으로 대입하면 인스턴스와 생성자 사이의 연결 고리가 끊어짐
    > constructor 프로퍼티가 없기 때문에
- 인스턴스와 생성자 사이의 연결 고리를 유지하려면 prototype으로 사용할 객체에 constructor 프로퍼티를 정의하고, 그 프로퍼티에 생성자의 참조를 대입해야 한다.

### 인스턴스 생성 후에 생성자의 프로토타입을 수정하거나 교체하는 경우
- 인스턴스의 프로퍼티는 생성되는 시점의 객체 프로토타입에서 상속받음
- 생성 이후의 생성자의 프로토타입이 수정이 있더라도 바뀌지 않음
    > 생성한 후에 생성자의 prototype 프로퍼티 값을 다른 객체로 교체해도 인스턴스의 프로토타입은 바뀌지 않음
- 기존에 가지고 있던 프로토타입 객체에 프로퍼티를 추가할 경우 사용 가능

## 4. 프로토타입의 확인
- instanceof 연산자
    + 지정한 객체의 프로토타입 체인에 지정한 생성자의 프로토타입 객체가 포함되어 있는지 판정
    + 논리값을 반환하는 이항 연산자
    + 해당 연산자로 생성되었는지 여부를 판단하는 것이 아닌 생성자의 프로토타입 객체를 상속받았는지 확인하는 것
    ```
    객체 instanceof 생성자
    ```

- isPrototypeOf 메서드
    + 특정 객체가 다른 객체의 프로토타입 체인에 포함되어 있는지 판정
    ```
    프로토타입객체.isPrototypeOf(객체)
    ```

## 5. Object.prototype
- Object 생성자는 객체를 생성하는 것보다 일반적인 객체를 조작하기 위한 메서드와 프로퍼티를 제공하고, Object.prototype으로 모든 내장 생성자 인스턴스에서 사용할 수 있는 메서드를 제공하는 것에 의의를 둠
- Object.prototype의 메서드
    + 인스턴스에서 프로토타입 체인을 따라 거슬러 올라갈 수 있는 마지막 단계의 객체

## 6. Object.create 로 객체 생성
- 명시적으로 객체를 생성 가능
- 객체 리터럴로 생성한 빈 객체와 똑같은 객체를 생성하려면
    ```
    var obj = Object.create(Object.prototype);
    ```
- 인자 값에 null를 넘길 경우 프로퍼티도 없는 객체가 생성돼 기본적인 메서드조차 사용할 수 없다.


# 3. 접근자 프로퍼티
## 1. 종류
1) 데이터 프로퍼티 : 값 저장
2) 접근자 프로퍼티 : 값은 없지만, 프로퍼티를 읽거나 쓸 때 호출하는 함수를 값 대신 지정할 수 있다.

## 2. 접근자
- 객체 지향 프로그래밍에서 객체가 가진 프로퍼티 값을 객체 바깥에서 읽거나 쓸 수 있도록 제공하는 메소드
- 접근자 프로퍼티를 사용해 객체 접근자를 정의할 수 있다.
    + 프로퍼티를 읽을 때 : 게터 함수
    + 프로퍼티를 쓸 때 : 세터 함수

```javascript
var person = {
    _name = "Tom",
    get name() {
        return this._name;
    },
    set name(value) {
        var str = value.charAt(0).toUpperCase() + value.substring(1);
        this._name = str;
    }
};    
```    
- getter가 없는 접근자 프로퍼티를 읽으려고 시도하면 undefined 반환
- strict 모드에서 setter가 없는 접근자 프로퍼티를 쓰려고 시도하면 오류

# 4. 프로퍼티의 속성
- 세 가지 내부 속성을 가지며 각 속성 값은 논리값
    + 쓰기 가능(writable)
    + 열거 가능(enumerable) 
    + 재정의 가능(configurable)
- 객체에 새로운 프로퍼티를 추가하면 기본적으로 '쓰기 가능/ 열거 가능/ 재정의 가능'으로 설정
- 하지만, 내장 생성자가 가지고 있는 프로토타입 객체의  프로퍼티 대부분의 내장 속성은 '쓰기 가능/ 열거 불가능/ 재정의 가능' 이다

## 프로퍼티 디스크립터와 프로퍼티를 읽고 쓰는 메서드
- 프로퍼티의 속성은 프로퍼티 디스크립터로 설정 가능

### 프로퍼티 디스크립터
- 프로퍼티의 속성 값을 뜻하는 객체
- 이 객체가 가진 프로퍼티 이름은 프로퍼티가 가진 속성 이름과 같음

- 데이터 프로퍼티 
    ```
    {
        value : 프로퍼티의 값,
        writable : 논리값,
        enumerable: 논리값,
        configurable: 논리값
    }
    ```
- 접근자 프로퍼티 
    ```
    {
        get : getter함수값,
        set : setter함수값,
        enumerable: 논리값,
        configurable: 논리값
    }
    ```
- 프로퍼티 메소드
    + Object.getOwnPropertyDescriptor : 객체 프로퍼티의 프로퍼티 디스크립터를 가져온다.
        ```
        Object.getOwnPropertyDescriptor(객체의 참조, 프로퍼티 이름);
        ```
    + Object.defineProperty : 객체의 프로퍼티 설정하기
        ```
        Object.defineProperty(객체의 참조, 프로퍼티 이름, 프로퍼티 디스크립터의 참조);
        >> 수정한 객체의 참조 반환
        ```
        * configurable 속성 값을 false로 바꾸면 writable 속성 값이 true 일 때 false 로 바꾸는 경우만 가능하다.
        * configurable 속성 값은 true > false 로 바뀌면 true 값으로 되돌릴 수 없다.
    + Object.defindProperties : 객체의 프로퍼티 속성 여러 개를 한꺼번에 설정하기

# 5. 프로퍼티가 있는지 확인하기
## 1. in 연산자
- 객체 안에 지명한 프로퍼티가 있는지 검색
- 검색 대상은 그 객체가 소유한 프로퍼티와 상속받은 프로퍼티

## 2. hasOwnProperty 메서드
- 지명한 프로퍼티가 해당 객체의 소유한 프로퍼티인지 확인 후 true/false 반환

## 3. propertyIsEnumerable 메서드
- 지정한 프로퍼티가 해당 객체의 소유한 프로퍼티며 열거할 수 있을때 true 반환

# 6. 열거
- for/in 문 
    + 객체와 객체의 프로토타입 체인에서 열거할 수 있는 프로퍼티를 찾아내어 꺼내는 반복문
- 객체가 소유한 프로퍼티만 열거하는 방법
    1) Object.keys 메서드
        + 지정한 객체가 소유한 프로퍼티  중에서 열거할 수 있는  프로퍼티 이름만 배열로 만들어서 반환
    2) Object.getOwnProperyNames 메서드
        + 인수로 지정한 객체가 소유한 프로퍼티 이름을 배열로 만들어 반환
        + 이때, 열거할 수 있는 프로퍼티와 열거할 수 없는 프로퍼티의 이름을 모두 배열로 만드는 특징을 가짐

# 7. 객체 잠그기
- 객체를 잠글 때 객체의 확장 가능 속성, 재정의 가능 속성, 쓰기 가능 속성 설정

## 확장 가능 속성
- 객체의 확장 가능(extensible) 속성은 객체에 새로운 프로퍼티를 추가할 수 있는지를 결정
- 사용자가 정의한 객체와 내장 객체는 기본적으로 확장이 가능하지만 호스트 객체의 확장 가능 속성은 자바스크립트 실행 환경에 따라 설정값이 다르다

### 1. 확장 방지 : Object.preventExtensions 메소드
- 인수로 받은 객체를 확장할 수 없게 만듬
- 프로퍼티를 추가할 수 없다.
- Object.isExtensible 메서드 : 인수로 지정한 객체가 확장 가능한지 확인

### 2. 밀봉 : Object.seal 메소드
- 인수로 받은 객체를 밀봉
- 값의 읽기/쓰기만 가능
- Object.isSealed 메서드 : 밀봉 여부 확인 가능

### 3. 동결 : Object.freeze 메소드
- 인수로 받은 객체 동결
- 동결 : 객체에 프로퍼티를 추가하는 것을 금지하고 기존의 모든 프로퍼티를 재정의할 수 없게 만들며 데이터 프로퍼티를 쓸 수 없게 만드는 것
    > 객체의 프로퍼티가 읽기만 가능한 상태
- Object.isFrozen 메서드 : 동결 여부 확인 가능

# 8. Mixin
- 특정 객체에 다른 객체가 가지고 있는 프로퍼티를 붙여 넣어 뒤섞는 기법
- 상속을 사용하지 않는 대신에 특정 객체의 프로퍼티를 동적으로 다른 객체에 추가
- 사용 방식 : 얕은 복사
- ES6 부터 Object.assign 메서드를 통해 작업 가능하며 이 경우는 깊은 복사가 된다.

> ##### 얕은 복사와 깊은 복사
> - 얕은 복사 : 객체의 참조만 복사하는 행위. 원본과 사본이 같은 객체를 참조
> - 깊은 복사 : 객체의 사본을 만들어 다른 메모리 영역에 복사하는 행위

# 9. JSON
- 자바스크립트 객체를 문자열로 표현하는 데이터 포맷
- 객체를 직렬화할 수 있다.

## JSON의 변환과 환원
### 객체 > JSON : JSON.stringify
- 유의사항
    + NaN, Infinity, -Infinity > null
    + Date 객체 > ISO 포맷의 날짜 문자열
    + Function, RegExp, Error 객체, undefined, 심벌은 직렬화할 수 없다.
    + 객체 자신이 가지고 있는 열거 가능한 프로퍼티만 직렬화 가능
    + 직렬화할 수 없는 프로퍼티는 문자열로 출력되지 않음
    + 프로퍼티 중 키가 심벌인 프로퍼티는 직렬화할 수 없다.

### JSON > 객체 : JSON.parse

> ##### JSON을 활용한 객체의 깊은 복사
> var copy = JSON.parse(JSON.stringify(obj)); 
> - 이 경우 가장 아래에 중첩된 객체의 프로퍼티는 값 타입이 primitive type 이어야 한다.
> - 어떠한 상황에서나 깊은 복사를 올바르게 수행하려면 Object.assign 메서드 사용하는 것이 좋다.


# 10. ES6 이후 추가 기능
## 1. 프로퍼티 이름으로 심벌 사용
- 함수 안에서 심벌을 생성하여 그것을 속성 이름으로 사용하고 그 프로퍼티에 값을 할당하면 함수 바깥에서 프로퍼티 값을 읽거나 쓸 수 없다. 
- 명시적으로 객체의 프로퍼티를 숨길 수 있다.
- 다음과 같은 방법으로 지정된 프로퍼티를 찾을 수 없다.
    + for/in 반복문
    + Object.keys
    + Object.getOwnPropertyNames
- Object.getOwnPropertySymbols 메서드를 사용해 가져올 수 있다.
- 내장 생성자 prototype의 안전한 확장을 위해 사용된다.

## 2. 객체 리터럴에 추가된 기능
1) 계산된 프로퍼티 이름(Computed Property Names): { [계산식]: value }
    - 임의의 계산식이 평가된 값을 프로퍼티 이름으로 사용할 수 있다.
2) 프로퍼티 정의의 약식 표기 : { prop }
3) 메서드 정의의 약속 표기 : { method() {} }
    - 프로퍼티 값으로 함수를 지정할 때 사용하는 약식 표기법 추가
    - 기존 코드와 차이점
        + 생성자로 사용할 수 없다. 즉, prototype 프로퍼티를 가지지 않으므로 new 연산자로 인스턴스를 생성할 수 없다.
        + super 키워드 사용 가능
4) 제너레이터 정의의 약식 표기 : { *generator() {} }
    - super 키워드 사용 가능