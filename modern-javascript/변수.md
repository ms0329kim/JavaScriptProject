# 데이터 타입
## 분류
+ 원시 타입(Primitive Type) 
    * number, string, boolean, undefined, null, Symbol
    * 변경 불가능한 값(immutable value), pass-by-value
+ 객체 타입
    * 원시 타입을 제외한 모든 것
    * pass-by-reference
> 리터럴 : 프로그램에 직접 참조할 수 있는 상수 값

1) number
- 64비트 부동소수점
- 정수 리터럴, 부동소수점 리터럴
- Infinity, -Infinity, NaN(산술 연산 불가)

2) string

3) boolean
    - truthy : falsy를  제외한 모든 것
    - falsy : 비어있는 문자열, null, undefined, 숫자 0 

4) undefined
    - 선언 이후 값을 할당하지 않는 상태
    - 선언은 되었지만 값을 할당하지 않는 변수에 접근하거나 존재하지 않는 객체 프로퍼티에 접근할 경우
    - 자바스크립트 엔진에 의해 초기화된 것 > 의도적인 할당은 권장하지 않는다.
    
5) null
    - 아무것도 없음을 값으로 표현한 리터럴
    - 아무것도 없음을 할당하는 값

6) Symbol
    - 유일무이한 값

# 변수
- 메모리 주소(memory address)에 접근하기 위한 식별자(identifier)
- var 문으로 선언하지 않은 변수값을 읽으려고 하면 참조 오류 발생
- 선언한 변수는 호이스팅된다.
    + 하지만, 선언과 동시에 대입할 경우 호이스팅되지 않음
- 자바스크립트는 동적 타입 언어(Dynamic / Weak Type) : 값의 할당 과정에서 변수 타입 결정(타입 추론), 여러 타입의 값 할당도 가능

## 변수의 유효 범위
- 유효 범위(Scope) : 변수에 접근할 수 있는 범위
    + 어휘적 범위(Lexical Scope) : 프로그램의 구문만으로 유효 범위를 정한 것
    + 동적 범위(Dynamic Scope) : 프로그램 실행 중에 유효 범위를 정한 것
- 변수의 유효 범위
    + 전역 변수
    + 지역 변수
        * var를 선언하지 않고 사용할 경우 함수 내에서 선언하지만 함수 밖에서도 사용 가능하다.
    + 호이스팅 된다.

## 호이스팅
- 모든 선언문이 해당 Scope의 선두로 옮겨지는 거처럼 동작하는 특성
- 변수는 3단계에 걸쳐 생성된다.
    1) 선언 단계
        + 변수 객체(Variable Object)에 변수를 등록한다. 이 변수 객체는 스코프가 참조하는 대상이 된다.

    2) 초기화 단계
        + 변수 객체(Variable Object)에 등록된 변수를 메모리에 할당한다. 이 단계에서 변수는 undefined로 초기화된다.
    
    3) 할당 단계
        + undefined로 초기화된 변수에 실제값을 할당한다.

- var 키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다.
    + 스코프에 변수가 등록되고 변수는 메모리에 공간을 확보한 후 undefined로 초기화
    + 변수 선언문 이전에 변수에 접근하여도 Variable Object에 변수가 존재하기 때문에 에러가 발생하지 않는다.        
        ```
                    -----------------------------------
        var foo;    |   선언단계    |   초기화 단계   |  foo === undefined 
                    ----------------------------------- 
        foo = 1     |           할당 단계             |  foo === 1
                    ----------------------------------- 
        ```  
- 자바스크립트의 변수는 블록 레벨 스코프를 가지지 않고 함수 레벨 스코프를 갖는다.
    + 블록 레벨 스코프(Block-level Scope)
        * 코드 블록 내에서 선언된 변수는 코드 블록 내에서만 유효하며 외부에서 참조할 수 없다.
        * let, const에서는 사용 가능하다.
    + 함수 레벨 스코프(Function-level Scope)
        * 함수 내에서 선언된 변수는 함수 내에서만 유효하며 외부에서 참조할 수 없다.
        * 함수 내부에서 선언한 변수는 지역 변수이며 함수 외부에서 선언한 변수는 모두 전역 변수이다.

## var 키워드
- 특징
    + 변수의 중복 선언
    + 암묵적 전역 변수
        *  var 키워드로 선언된 변수를 전역 변수로 사용하면 전역 객체의 프로퍼티가 된다.
    + 동적 타이핑
    + 변수 호이스팅
- var 키워드로 선언된 변수의 문제점
    1) 함수 레벨 스코프
        - 전역 변수의 남발
    2) var 키워드 생략 허용
    3) 중복 선언 허용
    4) 변수 호이스팅    

## let 과 const 
- 중괄호 안에서만 유효한 블록 유효 범위를 갖는 지역변수
- 블록 레벨 스코프를 따르게 한다.
- 변수 중복 선언이 되지 않는다. > Syntax Error 발생

- let 
    + 호이스팅 되지 않는다. > 스코프의 시작에서 변수의 선언까지 일시적 사각지대(Temporal Dead Zone; TDZ)에 빠지기 때문
    + 선언 단계와 초기화 단계가 분리되어 진행되기 때문
        * 스코프의 시작 지점부터 초기화 시작 지점까지의 구간 : 일시적 사각지대
        * 변수 선언 전 참조할 경우 referenceError 발생
        ```
                    ---------------------------------
                    |            선언단계           |
                    ---------------------------------
                    |   일시적 사각지대(TDZ) 단계   |
                    --------------------------------- 
        let foo;    |           초기화 단계         |   foo === undefined
                    --------------------------------- 
        foo = 1;    |            할당 단계          |   foo === 1
                    --------------------------------- 
                <let 키워드로 선언된 변수의 생명 주기>
        ```  

    + let 키워드로 선언된 변수를 전역 변수로 사용하는 경우 전역 객체의 프로퍼티가 아니다.
    ```javascript
    var foo = 123; // 전역변수
    console.log(window.foo); // 123

    let foo = 123;
    console.log(window.foo); // undefined
    ```                    

- const
    - 참조를 변경하지 못하기 때문에 재할당이 필요없을 경우 사용
        > ex) 객체 참조할 경우 : 객체 타입 변수에 할당된 주소값을 변경할 수 없지만 할당된 객체의 내용은 변경될 수 있으므로 객체의 프로퍼티는 수정된다.
    + 선언과 동시에 할당이 이루어져야 한다.
    + 주소의 재할당이 되지 않는다.
    + 불변적 바인딩을 할 뿐 불변적이지 않다.

- 권장사항
    + var 키워드 : ES6 이후 환경에서 권장하지 않는다.
    + let 키워드 : 재할당이 필요한 경우 변수의 스코프를 최대한 좁게 만들어 사용
    + const 키워드 : 원시값이나 객체에서 사용